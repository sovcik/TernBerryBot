#
# Subcalls used in programs generated by TernBerryBot
#

//-----------------------------------
subcall Forward {
    OUTPUT_TIME_SPEED(LAYER, MOTOR_BOTH, MOTOR_SPEED, 500, MOTOR_STEP, 500, BRAKE_STOP )
    CALL (wait_for_motors)
}

//-----------------------------------
subcall Backward {
    OUTPUT_TIME_SPEED(LAYER, MOTOR_BOTH, MOTOR_NEGATIVE_SPEED, 500, MOTOR_STEP, 500, BRAKE_STOP )
    CALL (wait_for_motors)
}

//-----------------------------------
subcall Left {
    OUTPUT_STEP_SPEED(LAYER, MOTOR_RIGHT, 25, 20, 180, 20, BRAKE_STOP)
    OUTPUT_STEP_SPEED(LAYER, MOTOR_LEFT, -25, 20, 180, 20, BRAKE_STOP)
    CALL (wait_for_motors)
}

//-----------------------------------
subcall Right {
    OUTPUT_STEP_SPEED(LAYER, MOTOR_RIGHT, -25, 20, 180, 20, BRAKE_STOP)
    OUTPUT_STEP_SPEED(LAYER, MOTOR_LEFT,   25, 20, 180, 20, BRAKE_STOP)
    CALL (wait_for_motors)
}

//-----------------------------------
subcall Spin {
    OUTPUT_STEP_SPEED(LAYER, MOTOR_RIGHT, -25, 20, 720, 20, BRAKE_STOP)
    OUTPUT_STEP_SPEED(LAYER, MOTOR_LEFT,   25, 20, 720, 20, BRAKE_STOP)
    CALL (wait_for_motors)
}

//-----------------------------------
subcall Shake {
    DATA32 timer
    DATA8  i
    MOVE8_8(0,i)
    shake_loop:
        OUTPUT_SPEED(LAYER, MOTOR_RIGHT, 20)
        OUTPUT_SPEED(LAYER, MOTOR_LEFT, -20)
        OUTPUT_START(LAYER, MOTOR_BOTH)
        TIMER_WAIT(10,timer)
        TIMER_READY(timer)
        OUTPUT_SPEED(LAYER, MOTOR_RIGHT, -20)
        OUTPUT_SPEED(LAYER, MOTOR_LEFT,  20)
        TIMER_WAIT(10,timer)
        TIMER_READY(timer)
        ADD8 (1,i,i)
    JR_LT8(i,10,shake_loop)
    OUTPUT_STOP(LAYER, MOTOR_BOTH, BRAKE_STOP)
}

//-----------------------------------
subcall Shuffle {
    DATA32 timer
    DATA8  i
    MOVE8_8(0,i)
    shuffle_loop:
        OUTPUT_SPEED(LAYER, MOTOR_BOTH, 20)
        OUTPUT_START(LAYER, MOTOR_BOTH)
        TIMER_WAIT(10,timer)
        TIMER_READY(timer)
        OUTPUT_SPEED(LAYER, MOTOR_BOTH, -20)
        TIMER_WAIT(10,timer)
        TIMER_READY(timer)
        ADD8 (1,i,i)
    JR_LT8(i,4,shuffle_loop)
    OUTPUT_STOP(LAYER, MOTOR_BOTH, BRAKE_STOP)
}

//-----------------------------------
subcall Wiggle {
    DATA32 timer
    DATA8  i
    MOVE8_8(0,i)
    wiggle_loop:
        OUTPUT_SPEED(LAYER, MOTOR_RIGHT, 50)
        OUTPUT_SPEED(LAYER, MOTOR_LEFT, 0)
        OUTPUT_START(LAYER, MOTOR_BOTH)
        TIMER_WAIT(50,timer)
        TIMER_READY(timer)
        OUTPUT_SPEED(LAYER, MOTOR_RIGHT, 0)
        OUTPUT_SPEED(LAYER, MOTOR_LEFT,  50)
        TIMER_WAIT(50,timer)
        TIMER_READY(timer)
        ADD8 (1,i,i)
    JR_LT8(i,5,wiggle_loop)
    OUTPUT_STOP(LAYER, MOTOR_BOTH, BRAKE_STOP)
}

//-----------------------------------
subcall Sing {
    SOUND(PLAY,SOUND_VOLUME,'up.rsf')
    SOUND_READY
    SOUND(PLAY,SOUND_VOLUME,'down.rsf')
    SOUND_READY
    SOUND(PLAY,SOUND_VOLUME,'up.rsf')
    SOUND_READY
}

//-----------------------------------
subcall Beep {
    SOUND(TONE,SOUND_VOLUME,600,500)
    SOUND_READY
}

//-----------------------------------
subcall Growl {
    SOUND(TONE,SOUND_VOLUME,500,500)
    SOUND_READY
}

//-----------------------------------
subcall Whistle {
    SOUND(TONE,SOUND_VOLUME,700,500)
    SOUND_READY
}

//-----------------------------------
subcall wait_for_motors {
    DATA32 timer
    DATA8	 yn

    motor_running:
        TIMER_WAIT(100,timer)
        TIMER_READY(timer)
        OUTPUT_TEST(LAYER, MOTOR_BOTH, yn)
    JR_TRUE(yn, motor_running)
}

//-----------------------------------
subcall StartMotor {
    IO_8 motor
    IO_8 speed
    OUTPUT_SPEED(LAYER, motor, speed)
    OUTPUT_START(LAYER, motor)
}

//-----------------------------------
subcall Wait {
    IO_32 wait_time
    DATA32 timer
    TIMER_WAIT(wait_time,timer)
    TIMER_READY(timer)
}
